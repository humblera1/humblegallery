<div style="text-align: center;">
  <br />  
  <img src="https://humblegallery.ru/favicon.png" alt="HumbleGallery Logo" />
  <h1>HumbleGallery</h1>
</div>

HumbleGallery — это онлайн галерея, в которой пользователи могут:
- Изучать информацию о художниках и их произведениях искусства.
- Открывать для себя различные техники, направления и жанры живописи.
- Формировать собственные коллекции картин, добавлять картины в избранное.
- Управлять своими коллекциями, добавляя либо удаляя картины.

В административной части приложения осуществляется управления сущностями приложения.

Приложение написано на Yii2 с использованием шаблона advanced. Фронтенд также использует webpack для сборки и оптимизации зависимостей.

# Запуск в режиме разработки

## 1. Требования

- **Docker**: Убедитесь, что Docker установлен и запущен на вашем компьютере.
- **Docker Compose**: Используется для координации работы нескольких контейнеров.
- **Git**: Для клонирования репозитория (если требуется).
- **.env файл**: В корне проекта должен располагаться файл `.env` с необходимыми переменными окружения.

## 2. Структура проекта и основные компоненты

Проект состоит из нескольких Docker-сервисов, которые запускаются с помощью файла `docker-compose.dev.yml`. Ниже приведено описание каждого сервиса:

- **nginx-dev**
   - **Образ**: `nginx:1.27.3-alpine`.
   - **Назначение**: Обслуживание статического контента и проксирование запросов к backend и frontend.
   - **Порты**: Для удобства проброшены переменные окружения `${FRONTEND_PORT}` и `${BACKEND_PORT}`.
   - **Тома**:
      - Корневая директория проекта монтируется в `/var/www`.
      - Конфигурационные файлы для nginx из `./docker/nginx/dev` монтируются в `/etc/nginx/conf.d/`.
      - Том для хранения загрузок (картины, обложки пользовательских коллекций, аватары).

- **app-dev**
   - **Образ**: Собран на основе кастомного `docker/php/dev.Dockerfile`.
   - **Назначение**: PHP-приложение.
   - **Тома**:
      - Проект монтируется в `/var/www`.
      - Том для хранения загрузок.
   - **Команда запуска**: Выполняется скрипт `start.sh`, который находится в `docker` директории.

- **webpack-dev**
   - **Образ**: `node:23.6.1-alpine`.
   - **Назначение**: Запуск сборщика модулей для frontend (webpack).
   - **Рабочая директория**: `/var/www`.
   - **Переменные окружения**:
      - `NODE_ENV=development`
      - `WATCHPACK_POLLING` (для корректной работы слежения за изменениями на Windows-машинах).
   - **Команда запуска**: Устанавливает зависимости и запускает сборку проекта с командой `npm run dev`.

- **mysql-dev**
   - **Образ**: `mysql:9.2.0`.
   - **Назначение**: Запуск базы данных MySQL.
   - **Порты**: Проброшен порт `${MYSQL_PORT}` на 3306 внутри контейнера.
   - **Переменные окружения**: Конфигурируются через переменные окружения (например, `MYSQL_ROOT_PASSWORD`, `MYSQL_DATABASE` и т.д.).
   - **Тома**: Используется том `db-data` для хранения данных базы.

Также определены следующие сети Docker:
- **internal**: Для внутренних коммуникаций между контейнерами (`app-dev` и `mysql-dev`), оставлена внешней для удобства подключения к базе из среды разработки.
- **web**: Связывает nginx, webpack и app.

## 3. Подготовка окружения

1. **Установите Docker и Docker Compose**  
   Следуйте инструкциям на [официальном сайте Docker](https://docs.docker.com/get-docker/) для установки Docker. Docker Compose обычно входит в стандартную установку Docker Desktop.

2. **Клонирование репозитория**
   ```bash
   git clone https://github.com/humblera1/humblegallery.git
   cd humblegallery

 **Настройка файла .env**

Создайте файл .env в корне проекта или используйте предоставленный шаблон:

```env
COMPOSE_PROJECT_NAME=humblegallery
FRONTEND_PORT=8080
BACKEND_PORT=8880
MYSQL_HOST=mysql
MYSQL_ROOT_PASSWORD=root_password
MYSQL_DATABASE=database_name
MYSQL_USER=your_database_user
MYSQL_PASSWORD=database_password
MYSQL_PORT=3336
```

Для запуска в режиме разработки задайте следующие переменные:

```env
YII_DEBUG=true
YII_ENV=dev
```
Сконфигурируйте:

```env
FRONTEND_CSRF_PARAM=_csrf-frontend
BACKEND_CSRF_PARAM=_csrf-backend
FRONTEND_COOKIE_VALIDATION_KEY=frontend-cookie-validation-key
BACKEND_COOKIE_VALIDATION_KEY=backend-cookie-validation-key
```

## 4. Запуск приложения

1. **Проверка Docker контейнеров**  
   Убедитесь, что Docker daemon запущен:
   ```bash
    docker info

2. **Запуск Docker Compose**  
   В терминале из корня проекта выполните команду:
   ```bash
   docker-compose -f docker-compose.dev.yml up -d

3. **Проверка статуса контейнеров**  
   Для проверки запущенных контейнеров выполните:
   ```bash
   docker-compose -f docker-compose.dev.yml ps

Вы должны увидеть, что все контейнеры (nginx-dev, app-dev, webpack-dev, mysql-dev) работают корректно.

4. **Запуск миграций**

   После инициализации выполните миграции:

    ```bash
    docker compose exec app-dev php yii migrate

5. **Доступ к приложению**  
   Откройте браузер и перейдите по адресу:

   - Для frontend: `http://localhost:<FRONTEND_PORT>` (http://localhost:8080)
   - Для backend: `http://localhost:<BACKEND_PORT>` (http://localhost:8888)

## 5. dev.Dockerfile, start.sh

### dev.Dockerfile
Данный файл содержит инструкции для сборки контейнера app-dev в режиме разработки. В нём обычно:
- Устанавливаются PHP и необходимые расширения.
- Настраиваются параметры PHP (включая отладочные настройки).
- Подготавливается структура контейнера для монтирования локальных директорий (см. раздел volumes в docker-compose.dev.yml).

Все изменения в вашем коде сразу доступны внутри контейнера благодаря тому, что локальные директории монтируются непосредственно в контейнер.

### start.sh
Скрипт start.sh запускается при старте контейнера app-dev и автоматизирует следующие шаги:

1. Настройка Xdebug логов
    - Создаёт директорию /var/log/xdebug для логирования Xdebug и задаёт правильные права доступа (пользователь www-data, права на запись).

2. Управление правами доступа к директориям
    - Устанавливает правильные права и владельца для папки uploads (тоже user: www-data), чтобы внутри контейнера можно было корректно загружать файлы.

3. Установка зависимостей Composer
    - Если директория vendor не существует, запускается команда composer install --no-interaction --prefer-dist, которая установит необходимые библиотеки для проекта.

4. Запуск php-fpm
    - Выполняется docker-php-entrypoint php-fpm --nodaemonize, что обеспечивает корректный запуск и работу PHP-FPM в контейнере с учётом всех загруженных php.ini и доп. конфигураций.

Таким образом, start.sh подготавливает окружение для отладки (через Xdebug), гарантирует корректные права доступа к нужным директориям и следит за тем, чтобы все зависимости были установлены перед запуском сервера PHP-FPM.


## Настройка Xdebug в PhpStorm (`serverName=app-dev`)

1. **Убедитесь, что Xdebug был верно установлен в контейнере app-dev**:
    - Проверьте, что в контейнере app-dev правильно сконфигурирован Xdebug и активна нужная версия PHP (`docker compose exec app-dev php -v`).
    - Убедитесь, что файл `docker/php/conf.d/xdebug.ini` содержит актуальные настройки, включая порт отладки (по умолчанию 9001).

2. **Создайте новый сервер в PhpStorm**
    1. В PhpStorm перейдите в «Settings» → «Languages & Frameworks» → «PHP» → «Servers».
    2. Нажмите «+», чтобы добавить новый сервер.
    3. В поле «Name» введите точное значение serverName, используемое Xdebug (`app-dev`), чтобы PhpStorm мог сопоставлять входящие запросы к правильному серверу.
    4. В поле «Host» укажите «localhost» (или IP-адрес, по которому вы обращаетесь к приложению).
    5. В поле «Port» укажите порт, на котором доступно приложение (например, 8080 для фронтенда или 8888 для бэкенда).
    6. Установите «Use path mappings», если ваша структура исходных файлов на локальной машине (host) отличается от структуры внутри контейнера. При необходимости добавьте соответствующие маппинги:
        - Локальный путь
        - Путь в контейнере`/var/www/`

3. **Настройка Debug в PhpStorm**
    - В разделе «Settings» → «PHP» → «Debug» убедитесь, что:
        - «Debug port» установлен на 9001.
        - «Can accept external connections» включён.
        - При необходимости включите/выключите «Break at first line in PHP scripts».

4. **Настройка запуска отладки**
    - Добавьте конфигурацию запуска отладки (Run → Edit Configurations… → «+» → PHP Remote Debug).
    - Выберите в поле «Server» ранее созданный сервер «app-dev».
    - Задайте имя конфигурации (например, «Debug app-dev»).

5. **Проверка и тестирование**
    - Запустите приложение в контейнерах и убедитесь, что PhpStorm слушает отладочные подключения (кнопка «Start Listening for PHP Debug Connections»).
    - Откройте вашу страницу (например, http://localhost:8080/ или http://localhost:8880/), где вы хотите отлаживать.
    - Если всё настроено корректно, PhpStorm перехватит выполнение при достижении брейкпоинта.


    
## **Webpack**

Автоматически, при запуске `docker compose` , включается режим наблюдения за файлами.
Так как директории хоста монтируются напрямую в контейнер в режиме разработки, webpack будет отслеживать изменения в файлах и пересобирать проект при необходимости.

# Запуск в режиме production

Для развёртывания проекта в production-окружении вы можете воспользоваться файлом `docker-compose.prod.yml`, в котором описана конфигурация контейнеров для рабочего (production) режима.

1. **Общие требования**
    - Убедитесь, что Docker и Docker Compose установлены и запущены.
    - Необходимо наличие корректно заполненного файла `.env` в корне проекта, в котором заданы переменные окружения для production (реальные пароли, ключи, настройки базы данных).

2. **Настройка окружения**
    - Проверьте, что в вашем `.env` файле установлены соответствующие переменные:
        - COMPOSE_PROJECT_NAME
        - MYSQL_HOST
        - MYSQL_ROOT_PASSWORD
        - MYSQL_DATABASE
        - MYSQL_USER
        - MYSQL_PASSWORD
    - Дополнительно укажите релевантные переменные для защиты и отладки, например:
        - YII_ENV=prod
        - YII_DEBUG=false
        - FRONTEND_COOKIE_VALIDATION_KEY и BACKEND_COOKIE_VALIDATION_KEY (поменяйте на уникальные ключи).

3. **Запуск контейнеров**
    - Выполните из корня проекта:
    ```bash
    docker compose -f docker-compose.prod.yml up -d
    ```
4. **Проверка статуса контейнеров**
    - Используйте:
    ```bash
    docker compose ps
    ```
    - Убедитесь, что все контейнеры запущены и работают штатно.

5. **Запуск и применение миграций**
    -  Чтобы выполнить миграции:
      ```bash
      docker docker compose exec app php yii migrate

Для прослушивания портов и маршрутизации на сервере используется Traefik.
Соответствующие метки представлены в контейнере Nginx.

Traefik работает как SSL-терминатор, после чего передаёт шифрованный трафик на Nginx.

# Деплой

Ниже описаны основные шаги, которые выполняет данный GitHub Actions Workflow для деплоя приложения:

## Событие запуска

Триггер срабатывает при пуше с тегом в формате `vX.X.X`.

## Сборка и пуш Docker-образов (Job: build)

На данном этапе происходит сборка всех необходимых образов (в соответствии с docker-compose.prod.yml) и последующая загрузка в Docker Hub.

## Деплой (Job: deploy)

Команды docker compose pull и docker compose up -d для обновляют контейнеры до новой версии.

## Секреты

Чтобы Workflow работал корректно, необходимо добавить в настройки GitHub Actions следующие секреты:

 - DOCKER_USERNAME — имя пользователя Docker Hub.
 - DOCKER_PASSWORD — пароль (или токен) для Docker Hub.
 - TIMEWEB_HOST — адрес сервера (хост).
 - TIMEWEB_USER — имя пользователя, под которым осуществляется вход.
 - SSH_PRIVATE_KEY — SSH-ключ.

# Дополнительно

## FileSaveBehavior

Данное поведение отвечает за процесс сохранения файлов: оно позволяет сохранять файлы в указанную директорию, генерировать имена файлов по заданному шаблону и при необходимости удалять старые файлы.
Чтобы использовать FileSaveBehavior, прикрепите его к классу ActiveRecord следующим образом:

```php
public function behaviors()
{
    return [
        'fileSave' => [
            'class' => FileSaveBehavior::class,
            'fileAttribute' => 'file',          // Атрибут, содержащий загружаемый файл
            'fileNameAttribute' => 'filename',  // Атрибут, в котором будет храниться имя файла
            'directoryPath' => 'app/uploads/',  // Путь до директории, куда сохраняются файлы
            'fileName' => '{slug}-{timestamp}.{extension}', // Шаблон для генерации имени файла
            'removeOldFile' => function($model) {
                // Условие, при котором нужно удалить старый файл
                return $model->isAttributeChanged('file');
            },
        ],
    ];
}
```

## Self-healing URLs

```php
    'container' => [
        'definitions' => [
            SelfHealingUrlHandlerInterface::class => CustomSelfHealingUrlHandlerTest::class,
        ],
    ],
```